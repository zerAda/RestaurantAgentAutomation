{
  "name": "W15 - Outbox Worker (Retry + DLQ)",
  "active": false,
  "settings": {
    "executionTimeout": 300,
    "saveExecutionProgress": true,
    "saveManualExecutions": true
  },
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "seconds",
              "secondsInterval": 30
            }
          ]
        }
      },
      "id": "outbox-worker-trigger",
      "name": "CRON - Every 30s",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [-2400, 0]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Outbox Worker - Check if enabled and get config\n */\nconst workerEnabled = (($env.OUTBOX_WORKER_ENABLED || 'true').toString().toLowerCase() !== 'false');\nconst batchSize = parseInt($env.OUTBOX_WORKER_BATCH_SIZE || '10', 10);\nconst maxAttempts = parseInt($env.OUTBOX_MAX_ATTEMPTS || '7', 10);\nconst baseDelaySec = parseInt($env.OUTBOX_BASE_DELAY_SEC || '30', 10);\nconst maxDelaySec = parseInt($env.OUTBOX_MAX_DELAY_SEC || '3600', 10);\n\nif (!workerEnabled) {\n  return [{ json: { skip: true, reason: 'WORKER_DISABLED' } }];\n}\n\nreturn [{\n  json: {\n    skip: false,\n    config: {\n      batchSize,\n      maxAttempts,\n      baseDelaySec,\n      maxDelaySec,\n      timestamp: new Date().toISOString()\n    }\n  }\n}];\n"
      },
      "id": "worker-config",
      "name": "B0 - Config",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-2150, 0]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.skip}}",
              "operation": "isFalse"
            }
          ]
        }
      },
      "id": "worker-enabled-check",
      "name": "B0 - Enabled?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-1900, 0]
    },
    {
      "parameters": {
        "operation": "get",
        "key": "ralphe:outbox:pending:count"
      },
      "id": "outbox-check-pending",
      "name": "B0 - Check Pending Count",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [-1650, -100],
      "credentials": {
        "redis": {
          "id": "REDIS_CREDENTIAL_ID",
          "name": "Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Pop batch from outbox pending queue\n * Using RPOP to get oldest first (FIFO)\n */\nconst config = $('B0 - Config').first().json.config;\nconst batchSize = config?.batchSize || 10;\n\n// We'll process one at a time in this simplified version\n// A more advanced version would use LRANGE + LTRIM\nreturn [{\n  json: {\n    config,\n    processNext: true,\n    queueKey: 'ralphe:outbox:pending'\n  }\n}];\n"
      },
      "id": "outbox-prepare-pop",
      "name": "B0 - Prepare Pop",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-1400, -100]
    },
    {
      "parameters": {
        "operation": "pop",
        "list": "ralphe:outbox:pending",
        "tail": true
      },
      "id": "outbox-rpop",
      "name": "B1 - RPOP Message",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [-1150, -100],
      "credentials": {
        "redis": {
          "id": "REDIS_CREDENTIAL_ID",
          "name": "Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Parse popped message and check if valid\n */\nconst raw = $json;\nconst config = $('B0 - Prepare Pop').first().json.config;\n\n// Redis returns null/undefined if queue is empty\nif (!raw || raw === 'nil' || raw === '' || (typeof raw === 'object' && Object.keys(raw).length === 0)) {\n  return [{ json: { empty: true, config } }];\n}\n\n// Try to parse JSON\nlet msg;\ntry {\n  msg = typeof raw === 'string' ? JSON.parse(raw) : raw;\n} catch (e) {\n  // Invalid JSON - log and skip\n  return [{ json: { empty: false, invalid: true, raw, error: e.message, config } }];\n}\n\n// Validate required fields\nif (!msg.channel || !msg.payload) {\n  return [{ json: { empty: false, invalid: true, msg, error: 'MISSING_REQUIRED_FIELDS', config } }];\n}\n\n// Calculate retry delay with exponential backoff\nconst attempts = (msg.attempts || 0) + 1;\nconst nextRetryAt = msg.nextRetryAt ? new Date(msg.nextRetryAt).getTime() : 0;\nconst now = Date.now();\n\n// Check if ready for retry\nif (nextRetryAt > now) {\n  // Not ready yet - re-queue with same data\n  return [{ json: { empty: false, notReady: true, msg, config, requeue: true } }];\n}\n\nreturn [{\n  json: {\n    empty: false,\n    invalid: false,\n    notReady: false,\n    msg: {\n      ...msg,\n      attempts\n    },\n    config\n  }\n}];\n"
      },
      "id": "outbox-parse-msg",
      "name": "B1 - Parse Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-900, -100]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.empty || $json.invalid}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "outbox-check-empty",
      "name": "B1 - Empty/Invalid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-650, -100]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.notReady}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "outbox-check-ready",
      "name": "B1 - Not Ready?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [-400, -200]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Re-queue message that's not ready for retry\n */\nconst data = $json;\nreturn [{\n  json: {\n    requeue: JSON.stringify(data.msg)\n  }\n}];\n"
      },
      "id": "outbox-prepare-requeue",
      "name": "B1 - Prepare Requeue",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-150, -300]
    },
    {
      "parameters": {
        "operation": "push",
        "list": "ralphe:outbox:pending",
        "messageData": "={{$json.requeue}}",
        "tail": true
      },
      "id": "outbox-requeue",
      "name": "B1 - LPUSH Requeue",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [100, -300],
      "credentials": {
        "redis": {
          "id": "REDIS_CREDENTIAL_ID",
          "name": "Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Prepare to send outbound message\n * Check dedupe key first\n */\nconst crypto = require('crypto');\nconst data = $json;\nconst msg = data.msg;\nconst config = data.config;\n\n// Generate dedupe key for outbound\nconst dedupeKey = `ralphe:outbox:sent:${msg.outboxMsgId || msg.msgId || crypto.randomUUID()}`;\n\nreturn [{\n  json: {\n    msg,\n    config,\n    dedupeKey,\n    channel: msg.channel,\n    payload: msg.payload\n  }\n}];\n"
      },
      "id": "outbox-prepare-send",
      "name": "B2 - Prepare Send",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-150, -100]
    },
    {
      "parameters": {
        "operation": "get",
        "key": "={{$json.dedupeKey}}"
      },
      "id": "outbox-dedupe-check",
      "name": "B2 - Dedupe Check",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [100, -100],
      "credentials": {
        "redis": {
          "id": "REDIS_CREDENTIAL_ID",
          "name": "Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Check if already sent (dedupe)\n */\nconst input = $('B2 - Prepare Send').first().json;\nconst dedupeResult = $json;\n\n// If key exists, message was already sent successfully\nif (dedupeResult && dedupeResult !== 'nil' && dedupeResult !== '') {\n  return [{ json: { ...input, alreadySent: true } }];\n}\n\nreturn [{ json: { ...input, alreadySent: false } }];\n"
      },
      "id": "outbox-dedupe-parse",
      "name": "B2 - Parse Dedupe",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [350, -100]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.alreadySent}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "outbox-already-sent",
      "name": "B2 - Already Sent?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [600, -100]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Send message to appropriate channel\n * Supports WA, IG, MSG\n */\nconst data = $json;\nconst msg = data.msg;\nconst config = data.config;\nconst channel = (msg.channel || '').toLowerCase();\nconst payload = msg.payload || {};\n\nconst timestamp = new Date().toISOString();\n\n// Get channel-specific config\nlet sendUrl, token, phoneNumberId, pageId;\nconst graphVersion = ($env.GRAPH_API_VERSION || 'v21.0').toString();\n\nif (channel === 'whatsapp' || channel === 'wa') {\n  sendUrl = ($env.WA_SEND_URL || '').toString().trim();\n  phoneNumberId = ($env.WA_PHONE_NUMBER_ID || '').toString().trim();\n  token = ($env.WA_API_TOKEN || '').toString().trim();\n  if (!sendUrl && phoneNumberId) {\n    sendUrl = `https://graph.facebook.com/${graphVersion}/${phoneNumberId}/messages`;\n  }\n} else if (channel === 'instagram' || channel === 'ig') {\n  sendUrl = ($env.IG_SEND_URL || '').toString().trim();\n  pageId = ($env.IG_PAGE_ID || '').toString().trim();\n  token = ($env.IG_API_TOKEN || '').toString().trim();\n  if (!sendUrl && pageId) {\n    sendUrl = `https://graph.facebook.com/${graphVersion}/${pageId}/messages`;\n  }\n} else if (channel === 'messenger' || channel === 'msg') {\n  sendUrl = ($env.MSG_SEND_URL || '').toString().trim();\n  pageId = ($env.MSG_PAGE_ID || '').toString().trim();\n  token = ($env.MSG_API_TOKEN || '').toString().trim();\n  if (!sendUrl && pageId) {\n    sendUrl = `https://graph.facebook.com/${graphVersion}/${pageId}/messages`;\n  }\n}\n\nif (!sendUrl) {\n  return [{ json: { ...data, sent: false, error: 'SEND_URL_NOT_CONFIGURED', channel, timestamp } }];\n}\nif (!token) {\n  return [{ json: { ...data, sent: false, error: 'API_TOKEN_NOT_CONFIGURED', channel, timestamp } }];\n}\n\nconst recipientId = (payload.userId || payload.recipientId || '').toString().trim();\nif (!recipientId) {\n  return [{ json: { ...data, sent: false, error: 'RECIPIENT_MISSING', channel, timestamp } }];\n}\n\n// Build request body based on channel\nlet body;\nconst isMetaApi = sendUrl.includes('graph.facebook.com');\n\nif (isMetaApi) {\n  const text = (payload.replyText || payload.text || '').toString().trim();\n  \n  if (channel === 'whatsapp' || channel === 'wa') {\n    body = {\n      messaging_product: 'whatsapp',\n      recipient_type: 'individual',\n      to: recipientId,\n      type: 'text',\n      text: { preview_url: false, body: text || '(empty)' }\n    };\n  } else {\n    // Instagram / Messenger\n    body = {\n      recipient: { id: recipientId },\n      message: { text: text || '(empty)' },\n      messaging_type: 'RESPONSE'\n    };\n  }\n} else {\n  // Mock API\n  body = {\n    channel,\n    to: recipientId,\n    text: payload.replyText || payload.text || '',\n    ...payload\n  };\n}\n\n// Send request\ntry {\n  const response = await $httpRequest({\n    method: 'POST',\n    url: sendUrl,\n    headers: {\n      'Authorization': `Bearer ${token}`,\n      'Content-Type': 'application/json'\n    },\n    body,\n    json: true,\n    timeout: 30000,\n    returnFullResponse: true\n  });\n  \n  const statusCode = response.statusCode || response.status || 200;\n  const responseBody = response.body || response.data || response;\n  \n  if (statusCode >= 200 && statusCode < 300) {\n    // Success!\n    return [{ json: {\n      ...data,\n      sent: true,\n      statusCode,\n      messageId: responseBody?.messages?.[0]?.id || responseBody?.message_id || null,\n      timestamp,\n      responseBody\n    }}];\n  }\n  \n  // Failed - determine if retryable\n  const retryable = statusCode === 429 || statusCode >= 500;\n  const dlqReason = statusCode === 401 ? 'AUTH_FAILED' : \n                    statusCode === 403 ? 'FORBIDDEN' : \n                    statusCode === 400 ? 'BAD_REQUEST' : 'HTTP_ERROR';\n  \n  return [{ json: {\n    ...data,\n    sent: false,\n    statusCode,\n    retryable,\n    dlqReason,\n    error: `HTTP_${statusCode}`,\n    timestamp,\n    responseBody\n  }}];\n  \n} catch (err) {\n  // Network error - retryable\n  return [{ json: {\n    ...data,\n    sent: false,\n    retryable: true,\n    error: 'NETWORK_ERROR',\n    errorMessage: err.message,\n    timestamp\n  }}];\n}\n"
      },
      "id": "outbox-send",
      "name": "B3 - Send Message",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, -200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.sent}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "outbox-send-ok",
      "name": "B3 - Send OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1100, -200]
    },
    {
      "parameters": {
        "operation": "set",
        "key": "={{$json.dedupeKey}}",
        "value": "={{$json.timestamp}}",
        "expire": true,
        "ttl": 604800
      },
      "id": "outbox-mark-sent",
      "name": "B3 - Mark Sent (Dedupe)",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1350, -300],
      "credentials": {
        "redis": {
          "id": "REDIS_CREDENTIAL_ID",
          "name": "Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "/**\n * P1-03: Handle send failure - retry or DLQ\n */\nconst data = $json;\nconst msg = data.msg;\nconst config = data.config;\nconst attempts = msg.attempts || 1;\nconst maxAttempts = config?.maxAttempts || 7;\nconst baseDelaySec = config?.baseDelaySec || 30;\nconst maxDelaySec = config?.maxDelaySec || 3600;\n\n// Check if should retry\nconst shouldRetry = data.retryable && attempts < maxAttempts;\n\nif (shouldRetry) {\n  // Calculate next retry time with exponential backoff\n  const delaySec = Math.min(baseDelaySec * Math.pow(2, attempts - 1), maxDelaySec);\n  const nextRetryAt = new Date(Date.now() + delaySec * 1000).toISOString();\n  \n  const retryMsg = {\n    ...msg,\n    attempts,\n    nextRetryAt,\n    lastError: data.error,\n    lastStatusCode: data.statusCode,\n    lastAttemptAt: data.timestamp\n  };\n  \n  return [{ json: {\n    action: 'retry',\n    retryMsg: JSON.stringify(retryMsg),\n    attempts,\n    nextRetryAt,\n    delaySec\n  }}];\n}\n\n// Move to DLQ\nconst dlqEntry = {\n  channel: msg.channel,\n  outboxMsgId: msg.outboxMsgId || msg.msgId,\n  payload: msg.payload,\n  attempts,\n  error: data.error,\n  statusCode: data.statusCode,\n  dlqReason: data.dlqReason || 'MAX_RETRIES_EXHAUSTED',\n  failedAt: data.timestamp,\n  lastResponseBody: data.responseBody\n};\n\nreturn [{ json: {\n  action: 'dlq',\n  dlqEntry: JSON.stringify(dlqEntry),\n  attempts,\n  error: data.error\n}}];\n"
      },
      "id": "outbox-handle-fail",
      "name": "B3 - Handle Failure",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1350, -100]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.action}}",
              "value2": "retry"
            }
          ]
        }
      },
      "id": "outbox-retry-or-dlq",
      "name": "B3 - Retry or DLQ?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1600, -100]
    },
    {
      "parameters": {
        "operation": "push",
        "list": "ralphe:outbox:pending",
        "messageData": "={{$json.retryMsg}}",
        "tail": true
      },
      "id": "outbox-push-retry",
      "name": "B4 - LPUSH Retry",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1850, -200],
      "credentials": {
        "redis": {
          "id": "REDIS_CREDENTIAL_ID",
          "name": "Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "operation": "push",
        "list": "ralphe:dlq",
        "messageData": "={{$json.dlqEntry}}"
      },
      "id": "outbox-push-dlq",
      "name": "B4 - Push to DLQ",
      "type": "n8n-nodes-base.redis",
      "typeVersion": 1,
      "position": [1850, 0],
      "credentials": {
        "redis": {
          "id": "REDIS_CREDENTIAL_ID",
          "name": "Redis"
        }
      },
      "continueOnFail": true
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "// P1-03: Worker cycle complete - success\nreturn [{ json: { status: 'SUCCESS', timestamp: new Date().toISOString() } }];\n"
      },
      "id": "end-success",
      "name": "END - Success",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, -300]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "// P1-03: Worker cycle complete - retry scheduled\nreturn [{ json: { status: 'RETRY_SCHEDULED', attempts: $json.attempts, timestamp: new Date().toISOString() } }];\n"
      },
      "id": "end-retry",
      "name": "END - Retry Scheduled",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2100, -200]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "// P1-03: Worker cycle complete - moved to DLQ\nreturn [{ json: { status: 'DLQ', error: $json.error, timestamp: new Date().toISOString() } }];\n"
      },
      "id": "end-dlq",
      "name": "END - DLQ",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2100, 0]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "// P1-03: Worker cycle complete - queue empty or skipped\nreturn [{ json: { status: 'IDLE', reason: $json.reason || 'QUEUE_EMPTY', timestamp: new Date().toISOString() } }];\n"
      },
      "id": "end-idle",
      "name": "END - Idle",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [-400, 100]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "// P1-03: Already sent - skip (dedupe)\nreturn [{ json: { status: 'SKIPPED_DUPLICATE', dedupeKey: $json.dedupeKey, timestamp: new Date().toISOString() } }];\n"
      },
      "id": "end-duplicate",
      "name": "END - Duplicate",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [850, 0]
    }
  ],
  "connections": {
    "CRON - Every 30s": {
      "main": [
        [
          {
            "node": "B0 - Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Config": {
      "main": [
        [
          {
            "node": "B0 - Enabled?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Enabled?": {
      "main": [
        [
          {
            "node": "B0 - Check Pending Count",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "END - Idle",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Check Pending Count": {
      "main": [
        [
          {
            "node": "B0 - Prepare Pop",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Prepare Pop": {
      "main": [
        [
          {
            "node": "B1 - RPOP Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1 - RPOP Message": {
      "main": [
        [
          {
            "node": "B1 - Parse Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1 - Parse Message": {
      "main": [
        [
          {
            "node": "B1 - Empty/Invalid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1 - Empty/Invalid?": {
      "main": [
        [
          {
            "node": "END - Idle",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B1 - Not Ready?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1 - Not Ready?": {
      "main": [
        [
          {
            "node": "B1 - Prepare Requeue",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B2 - Prepare Send",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1 - Prepare Requeue": {
      "main": [
        [
          {
            "node": "B1 - LPUSH Requeue",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1 - LPUSH Requeue": {
      "main": [
        [
          {
            "node": "END - Idle",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B2 - Prepare Send": {
      "main": [
        [
          {
            "node": "B2 - Dedupe Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B2 - Dedupe Check": {
      "main": [
        [
          {
            "node": "B2 - Parse Dedupe",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B2 - Parse Dedupe": {
      "main": [
        [
          {
            "node": "B2 - Already Sent?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B2 - Already Sent?": {
      "main": [
        [
          {
            "node": "END - Duplicate",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B3 - Send Message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B3 - Send Message": {
      "main": [
        [
          {
            "node": "B3 - Send OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B3 - Send OK?": {
      "main": [
        [
          {
            "node": "B3 - Mark Sent (Dedupe)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B3 - Handle Failure",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B3 - Mark Sent (Dedupe)": {
      "main": [
        [
          {
            "node": "END - Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B3 - Handle Failure": {
      "main": [
        [
          {
            "node": "B3 - Retry or DLQ?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B3 - Retry or DLQ?": {
      "main": [
        [
          {
            "node": "B4 - LPUSH Retry",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B4 - Push to DLQ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B4 - LPUSH Retry": {
      "main": [
        [
          {
            "node": "END - Retry Scheduled",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B4 - Push to DLQ": {
      "main": [
        [
          {
            "node": "END - DLQ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}
