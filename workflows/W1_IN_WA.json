{
  "name": "W1 - IN WhatsApp Adapter (Secure)",
  "active": false,
  "settings": {
    "executionTimeout": 300,
    "saveExecutionProgress": true,
    "saveManualExecutions": true
  },
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "v1/inbound/whatsapp",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "id": "6b6bf307-4caa-4d32-8a17-27ffa1967f1b",
      "name": "IN - Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -2400,
        0
      ]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "const crypto = require('crypto');\nconst fs = require('fs');\nconst path = require('path');\n\nconst body = $json.body ?? $json;\nconst headers = ($json.headers ?? $json?.headers ?? {});\nconst qs = ($json.query || $json.qs || {});\n\nfunction normVersion(v) {\n  const s = (v || '').toString().trim().toLowerCase();\n  if (!s) return 'v1';\n  if (s === '1' || s === 'v1') return 'v1';\n  if (s === '2' || s === 'v2') return 'v2';\n  return 'unknown';\n}\n\nconst headerVer = headers['x-contract-version'] || headers['X-Contract-Version'] || headers['x_contract_version'] || '';\nconst bodyVer = body.contract_version || body.contractVersion || '';\nconst contractVersion = normVersion(headerVer || bodyVer || 'v1');\n\nconst auth = (headers['authorization'] || headers['Authorization'] || '').toString();\nconst bearer = auth.toLowerCase().startsWith('bearer ') ? auth.slice(7).trim() : '';\n\nconst headerToken = (\n  headers['x-api-token'] || headers['X-Api-Token'] ||\n  headers['x-webhook-token'] || headers['X-Webhook-Token'] ||\n  ''\n).toString().trim();\n\nconst allowQueryToken = (($env.ALLOW_QUERY_TOKEN || 'false').toString().toLowerCase() === 'true');\nconst queryTokenProvided = !!(qs['token'] || qs['access_token']);\nconst queryToken = allowQueryToken ? (qs['token'] || qs['access_token'] || '') : '';\n\nconst token = (headerToken || bearer || queryToken || '').toString().trim();\nconst queryTokenUsed = !!queryToken && !headerToken && !bearer;\n\nconst shared = ($env.WEBHOOK_SHARED_TOKEN || '').toString().trim();\nconst legacySharedConfigured = !!shared;\nconst legacySharedValid = !!token && legacySharedConfigured && (token === shared);\n\n// Meta/WhatsApp signature verification (X-Hub-Signature-256)\nconst metaSig = (headers['x-hub-signature-256'] || headers['X-Hub-Signature-256'] || '').toString().trim();\nconst metaSecret = ($env.META_APP_SECRET || '').toString();\nconst metaSigRequired = (($env.META_SIGNATURE_REQUIRED || 'false').toString().toLowerCase() === 'true');\n\nfunction timingSafeEq(a,b){\n  try{\n    const ba = Buffer.from(String(a));\n    const bb = Buffer.from(String(b));\n    if (ba.length !== bb.length) return false;\n    return crypto.timingSafeEqual(ba, bb);\n  }catch{ return false; }\n}\n\nlet metaSigValid = null;\nlet metaSigReason = '';\nif (!metaSig) {\n  metaSigValid = metaSigRequired ? false : null;\n  metaSigReason = 'signature_missing';\n} else if (!metaSecret) {\n  metaSigValid = false;\n  metaSigReason = 'secret_missing';\n} else {\n  const raw = ($json.rawBody && typeof $json.rawBody === 'string') ? $json.rawBody : JSON.stringify(body || {});\n  const expected = 'sha256=' + crypto.createHmac('sha256', metaSecret).update(raw, 'utf8').digest('hex');\n  metaSigValid = timingSafeEq(expected, metaSig);\n  metaSigReason = metaSigValid ? 'ok' : 'invalid';\n}\n\nconst ipRaw = (headers['x-forwarded-for'] || headers['X-Forwarded-For'] || '').toString();\nconst ip = ipRaw.split(',')[0].trim();\n\nconst inboundReceivedAt = new Date().toISOString();\n\n// Hints from body (NEVER trusted)\nconst tenantHint = (body.tenantId || body.tenant_id || body.tenant || '').toString();\nconst restaurantHint = (body.restaurantId || body.restaurant_id || body.restaurant || '').toString();\n\n// Detect canonical envelope\nconst looksLikeV1 = body && typeof body === 'object' && body.provider && (body.msg_id || body.msgId) && (body.from || body.sender || body.sender_id);\nconst looksLikeV2 = body && typeof body === 'object' && body.provider && body.sender && body.message && (body.msg_id || body.msgId);\n\nfunction buildEnvelopeLegacy() {\n  const userId = (body.userId || body.from || body.sender || body.sender_id || 'unknown-user').toString();\n  const msgId = (body.msgId || body.messageId || body.mid || body.message?.id || body.message?.mid || crypto.randomUUID()).toString();\n  const text = (body.text || body.message?.text || body.message?.body || '').toString();\n\n  const buttonId = (body.buttonId || body.interactive?.button_reply?.id || body.message?.buttonId || '').toString();\n  const audioUrl = (body.audioUrl || body.audio?.url || body.message?.audio?.url || '').toString();\n  const audioMime = (body.audio?.mime || body.message?.audio?.mime || 'audio/ogg').toString();\n  const imageUrl = (body.imageUrl || body.image?.url || body.message?.image?.url || '').toString();\n  const imageMime = (body.image?.mime || body.message?.image?.mime || 'image/jpeg').toString();\n\n  let attachments = [];\n  if (audioUrl) attachments.push({type:'audio', url: audioUrl, mime: audioMime});\n  if (imageUrl) attachments.push({type:'image', url: imageUrl, mime: imageMime});\n\n  const locale = (body.locale || body.meta?.locale || '').toString();\n  const timezone = (body.timezone || body.meta?.timezone || '').toString();\n\n  return {\n    contract_version: contractVersion === 'unknown' ? 'v1' : contractVersion,\n    provider: 'wa',\n    msg_id: msgId,\n    from: userId,\n    text: buttonId ? buttonId : text,\n    timestamp: (body.timestamp || body.time || body.meta?.timestamp || inboundReceivedAt).toString(),\n    attachments,\n    meta: {\n      locale: locale || undefined,\n      timezone: timezone || undefined,\n      ip: ip || undefined,\n      user_agent: (headers['user-agent'] || headers['User-Agent'] || '').toString() || undefined\n    },\n    tenant_context: {\n      source: 'untrusted_payload',\n      hints: {\n        tenant_hint: tenantHint || undefined,\n        restaurant_hint: restaurantHint || undefined\n      }\n    }\n  };\n}\n\nfunction buildEnvelopeFromV1(obj) {\n  return {\n    contract_version: 'v1',\n    provider: (obj.provider || 'wa').toString(),\n    msg_id: (obj.msg_id || obj.msgId).toString(),\n    from: (obj.from || obj.sender || obj.sender_id).toString(),\n    text: (obj.text || '').toString(),\n    timestamp: (obj.timestamp || inboundReceivedAt).toString(),\n    attachments: Array.isArray(obj.attachments) ? obj.attachments : [],\n    meta: obj.meta || {},\n    tenant_context: obj.tenant_context || obj.tenantContext || {\n      source: 'untrusted_payload',\n      hints: { tenant_hint: tenantHint || undefined, restaurant_hint: restaurantHint || undefined }\n    }\n  };\n}\n\nfunction buildEnvelopeFromV2(obj) {\n  return {\n    contract_version: 'v2',\n    provider: (obj.provider || 'wa').toString(),\n    msg_id: (obj.msg_id || obj.msgId).toString(),\n    sender: {\n      id: (obj.sender?.id || obj.sender?.from || obj.sender?.userId || '').toString(),\n      display_name: (obj.sender?.display_name || obj.sender?.displayName || '').toString() || undefined\n    },\n    message: {\n      text: (obj.message?.text || '').toString() || undefined,\n      attachments: Array.isArray(obj.message?.attachments) ? obj.message.attachments : []\n    },\n    timestamp: (obj.timestamp || inboundReceivedAt).toString(),\n    meta: obj.meta || {},\n    tenant_context: obj.tenant_context || obj.tenantContext || {\n      source: 'untrusted_payload',\n      hints: { tenant_hint: tenantHint || undefined, restaurant_hint: restaurantHint || undefined }\n    }\n  };\n}\n\nlet envelope;\nlet normalizedVersion = contractVersion;\nif (normalizedVersion === 'unknown') {\n  envelope = null;\n} else if (normalizedVersion === 'v2') {\n  // strict: if caller requested v2, we validate as v2 (no fallback to v1)\n  envelope = buildEnvelopeFromV2(body);\n} else if (normalizedVersion === 'v1' && looksLikeV1 && !looksLikeV2) {\n  envelope = buildEnvelopeFromV1(body);\n} else {\n  // legacy or mismatch => compat layer (v1)\n  normalizedVersion = 'v1';\n  envelope = buildEnvelopeLegacy();\n}\n\n// Validate envelope against schema\nlet isValid = false;\nlet errors = [];\nlet schemaHash = '';\nlet schemaPath = '';\nlet validator = 'ajv';\n\ntry {\n  if (!envelope) throw new Error('unknown_contract_version');\n  if ((envelope.provider || '').toString() !== 'wa') throw new Error('provider_mismatch');\n  const schemasRoot = ($env.SCHEMAS_ROOT || '/opt/resto/schemas').toString();\n  schemaPath = path.join(schemasRoot, 'inbound', `${envelope.contract_version}.json`);\n  const schemaText = fs.readFileSync(schemaPath, 'utf8');\n  schemaHash = crypto.createHash('sha256').update(schemaText).digest('hex');\n  const schema = JSON.parse(schemaText);\n\n  let Ajv;\n  try { Ajv = require('ajv'); } catch (e) { Ajv = null; }\n  if (!Ajv) {\n    validator = 'basic';\n    // Hard fail: schema validation must be available in production\n    throw new Error('ajv_not_available');\n  }\n  const ajv = new Ajv({allErrors:true, strict:false, allowUnionTypes:true});\n  const validate = ajv.compile(schema);\n  isValid = validate(envelope);\n  if (!isValid) {\n    errors = (validate.errors || []).slice(0, 10).map(e => ({path: e.instancePath || '', message: e.message || 'invalid'}));\n  }\n} catch (err) {\n  isValid = false;\n  errors = [{path:'', message: (err && err.message) ? err.message : 'validation_error'}];\n}\n\nconst tokenHash = token ? crypto.createHash('sha256').update(token).digest('hex') : '';\n\n// Build internal canonical message (keep existing fields)\nconst ch = 'whatsapp';\nconst userId = envelope?.contract_version === 'v2'\n  ? (envelope.sender?.id || '').toString()\n  : (envelope?.from || '').toString();\n\nconst msgId = envelope?.contract_version === 'v2'\n  ? (envelope.msg_id || '').toString()\n  : (envelope?.msg_id || '').toString();\n\nconst text = envelope?.contract_version === 'v2'\n  ? ((envelope.message?.text || '')).toString()\n  : ((envelope?.text || '')).toString();\n\nconst atts = envelope?.contract_version === 'v2'\n  ? (Array.isArray(envelope.message?.attachments) ? envelope.message.attachments : [])\n  : (Array.isArray(envelope.attachments) ? envelope.attachments : []);\n\nconst firstAudio = Array.isArray(atts) ? atts.find(a => a && a.type === 'audio' && a.url) : null;\nconst firstImage = Array.isArray(atts) ? atts.find(a => a && a.type === 'image' && a.url) : null;\n\nlet type = 'text';\nif (firstAudio) type = 'audio';\nif (firstImage) type = 'image';\n\nconst textHash = crypto.createHash('sha256').update((text || '').toString()).digest('hex');\n\nreturn [{\n  json: {\n    channel: ch,\n    userId: userId || (body.userId || body.from || body.sender || 'unknown-user').toString(),\n    tenantId: '',\n    restaurantId: '',\n    conversationKey: '',\n    roleHint: body.roleHint || 'customer',\n    contract_version: normalizedVersion,\n    inbound_envelope: envelope,\n    metadata: {\n      msgId: msgId || (body.msgId || body.messageId || crypto.randomUUID()).toString(),\n      timestamp: envelope?.timestamp || inboundReceivedAt,\n      ip,\n      userAgent: (headers['user-agent'] || headers['User-Agent'] || '').toString(),\n      testMode: !!body.testMode\n    },\n    message: {\n      type,\n      text: (text || '').toString().trim(),\n      buttonId: '',\n      audio: firstAudio ? { url: firstAudio.url, mime: firstAudio.mime || 'audio/ogg' } : null,\n      image: firstImage ? { url: firstImage.url, mime: firstImage.mime || 'image/jpeg' } : null\n    },\n    tenant_context_hints: {\n      tenant_hint: tenantHint || '',\n      restaurant_hint: restaurantHint || ''\n    },\n    _contract: {\n      version: normalizedVersion,\n      schemaPath,\n      schemaHash,\n      validator,\n      isValid,\n      errors\n    },\n    _timing: {\n      inbound_received_at: inboundReceivedAt\n    },\n    _auth: {\n      tokenPresent: !!token,\n      tokenHash,\n      legacySharedConfigured,\n      legacySharedValid,\n      \n    metaSigPresent: !!metaSig,\n    metaSigRequired,\n    metaSigValid,\n    metaSigReason,\nallowQueryToken,\n      queryTokenProvided,\n      queryTokenUsed,\n      tenantHint,\n      restaurantHint\n    },\n    _sec: {\n      textHash\n    },\n    raw: body\n  }\n}];\n"
      },
      "id": "57c1bc81-2ffe-4ec4-bb34-c90c01c8da25",
      "name": "B0 - Parse & Canonicalize",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -2150,
        0
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._auth.authOk}}",
              "operation": "isTrue"
            },
            {
              "value1": "={{$json._auth.scopeOk}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "e85f72b6-33ee-4917-b68a-2a26e4aa1c74",
      "name": "B0 - Token OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1920,
        0
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ins AS (\n      INSERT INTO idempotency_keys (conversation_key, msg_id, channel)\n      VALUES ($1, $2, $3)\n      ON CONFLICT DO NOTHING\n      RETURNING 1\n    )\n    SELECT COALESCE((SELECT 1 FROM ins), 0) AS inserted;",
        "additionalFields": {
          "queryParams": "={{[$json.conversationKey, $json.metadata.msgId, $json.channel]}}"
        }
      },
      "id": "6a310cae-d2a9-46d3-9e16-da8f577f5064",
      "name": "B0 - Idempotency (DB)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        -1700,
        -120
      ]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "const inserted = Number($json.inserted || 0);\nreturn [{json: {...$json, _sec: {...$json._sec, isNew: inserted === 1}}}];"
      },
      "id": "57be4e3e-a55b-4bb7-ac99-5850a5b438bc",
      "name": "B0 - Idempotency Flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1480,
        -120
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._sec.isNew}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "449a1c07-5aa5-426e-97a1-f16003a3fa19",
      "name": "B0 - Is New Msg?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -1260,
        -120
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH ins AS (\n      INSERT INTO inbound_messages (conversation_key, msg_id, channel, message_type, text_hash, meta_json)\n      VALUES ($1, $2, $3, $4, $5, $6::jsonb)\n      ON CONFLICT DO NOTHING\n      RETURNING 1\n    )\n    SELECT COUNT(*)::int AS cnt_30s\n    FROM inbound_messages\n    WHERE conversation_key = $1\n      AND received_at > (now() - interval '30 seconds');",
        "additionalFields": {
          "queryParams": "={{[$json.conversationKey, $json.metadata.msgId, $json.channel, $json.message.type, $json._sec.textHash, JSON.stringify({ip:$json.metadata.ip,ua:$json.metadata.userAgent})]}}"
        }
      },
      "id": "25e66261-e0cb-482f-a28c-26da58fbc564",
      "name": "B0 - RateLimit + Log",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        -1040,
        -240
      ]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "const limit = Number($env.RATE_LIMIT_PER_30S || 6);\nconst cnt = Number($json.cnt_30s || 0);\nconst allowed = cnt <= limit;\nreturn [{json: {...$json, _sec: {...$json._sec, rateCnt30s: cnt, rateAllowed: allowed}}}];"
      },
      "id": "95df564e-ace1-4aab-9f4f-ae332a28b985",
      "name": "B0 - RateLimit Flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -820,
        -240
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._sec.rateAllowed}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "6609e416-2946-4521-b1e7-bda46a695942",
      "name": "B0 - Rate OK?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -600,
        -240
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT 1 AS quarantined\n    FROM conversation_quarantine\n    WHERE conversation_key=$1 AND active=true\n      AND (expires_at IS NULL OR expires_at > now())\n    LIMIT 1;",
        "additionalFields": {
          "queryParams": "={{[$json.conversationKey]}}"
        }
      },
      "id": "0437a2d3-aa7e-4f50-bbc0-632a8b300b53",
      "name": "B0 - Quarantine Check",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        -380,
        -360
      ]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "const q = ($json.quarantined === 1 || $json.quarantined === '1');\nconst notQ = !q;\nreturn [{json: {...$json, _sec: {...$json._sec, notQuarantined: notQ}}}];"
      },
      "id": "fb4efc11-e382-4ca4-951d-e0764859acd5",
      "name": "B0 - Quarantine Flag",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -360
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._sec.notQuarantined}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "ae5c99ae-3bc7-4b29-b278-d3bf8892aa05",
      "name": "B0 - Not Quarantined?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        60,
        -360
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{(($env.ADMIN_WA_CONSOLE_ENABLED||'false').toString().toLowerCase()==='true') && (($json.message?.text||'').toString().trim().startsWith('!'))}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "175878db-624a-45bd-ba96-4b57ba9bcb69",
      "name": "B1a - Admin WA Console?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [
        -60,
        200
      ]
    },
    {
      "parameters": {
        "workflowId": "={{$env.ADMIN_WA_CONSOLE_WORKFLOW_ID}}",
        "waitTillFinished": false,
        "options": {},
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "json": "={{$json}}"
          }
        }
      },
      "id": "d46323fe-0768-485c-9d7c-ad1ab3c3b909",
      "name": "B1b - Execute ADMIN_WA_CONSOLE",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 2,
      "position": [
        160,
        60
      ]
    },
    {
      "parameters": {
        "workflowId": "={$env.CORE_WORKFLOW_ID}",
        "options": {
          "waitTillFinished": false
        }
      },
      "id": "4393479e-8bfa-4823-bc3a-cb94d9166000",
      "name": "B1 - Execute CORE_AGENT",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1,
      "position": [
        300,
        -360
      ]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "return [{json:{ok:true}}];"
      },
      "id": "2d849a6a-35b3-47d1-b3f4-5a80234691e8",
      "name": "END - Drop/Done",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        0
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "WITH c AS (  SELECT client_id, client_name, tenant_id, restaurant_id, scopes  FROM api_clients  WHERE is_active=true AND token_hash = $1  LIMIT 1) SELECT   (SELECT client_id FROM c) AS client_id,   (SELECT client_name FROM c) AS client_name,   (SELECT tenant_id FROM c) AS tenant_id,   (SELECT restaurant_id FROM c) AS restaurant_id,   COALESCE((SELECT scopes FROM c), '[]'::jsonb) AS scopes,   EXISTS(SELECT 1 FROM c) AS matched;",
        "additionalFields": {
          "queryParams": "={{[$json._auth.tokenHash]}}"
        }
      },
      "id": "6954cbb3-8346-4255-b5c7-5aa8aa9e81e5",
      "name": "B0 - Resolve Client (DB)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        280,
        -120
      ]
    },
    {
      "parameters": {
        "language": "javascript",
        "jsCode": "const e = $json;\nconst matched = !!e.matched;\nconst legacyOk = !!e._auth?.legacySharedValid;\nconst legacyAllowed = (($env.LEGACY_SHARED_ALLOWED || 'false').toString().toLowerCase() === 'true');\n\n// Meta signature enforcement (fail-close only if META_SIGNATURE_REQUIRED=true)\nconst metaSigRequired = !!e._auth?.metaSigRequired;\nconst metaSigValid = (e._auth?.metaSigValid === true);\nconst metaSigPresent = !!e._auth?.metaSigPresent;\nconst metaSigReason = (e._auth?.metaSigReason || '').toString();\n\nlet tenantId = '';\nlet restaurantId = '';\nlet authMode = 'deny';\nlet scopes = [];\n\nif (matched && e.tenant_id && e.restaurant_id) {\n  tenantId = e.tenant_id.toString();\n  restaurantId = e.restaurant_id.toString();\n  authMode = 'api_client';\n  // scopes may be returned as array or string\n  try { scopes = Array.isArray(e.scopes) ? e.scopes : (typeof e.scopes === 'string' ? JSON.parse(e.scopes) : (e.scopes?.scopes || [])); } catch { scopes = []; }\n} else if (legacyOk && legacyAllowed) {\n  // Legacy fallback to keep backward compatibility (MVP)\n  tenantId = '00000000-0000-0000-0000-000000000001';\n  restaurantId = '00000000-0000-0000-0000-000000000000';\n  authMode = 'legacy_shared';\n  scopes = ['legacy_shared'];\n}\n\nconst conversationKey = tenantId ? (tenantId + ':' + restaurantId + ':' + e.channel + ':' + e.userId) : '';\nlet authOk = authMode !== 'deny';\n\n// ---- Scopes enforcement (Release-grade)\n// Required scopes are per-endpoint (here: inbound).\nconst requiredScopes = ['inbound:write'];\n\nfunction hasScope(required, granted) {\n  if (!required) return true;\n  const g = new Set((granted || []).map(s => String(s || '').trim()).filter(Boolean));\n  if (g.has(required)) return true;\n  if (g.has('*')) return true;\n  const parts = String(required).split(':');\n  if (parts.length === 2 && g.has(`${parts[0]}:*`)) return true;\n  return false;\n}\n\n// Legacy token can keep inbound compatibility, but MUST NOT be used for admin/internal.\nconst legacyBypass = (authMode === 'legacy_shared') && requiredScopes.some(s => s.startsWith('inbound:'));\nconst scopeOk = authOk && (legacyBypass || requiredScopes.length === 0 || requiredScopes.some(r => hasScope(r, scopes)));\n\nconst endpoint_group = 'inbound';\nconst endpoint_path = '/v1/inbound/whatsapp';\n\nlet denyReason = authOk ? (scopeOk ? '' : 'SCOPE_DENY') : 'AUTH_DENY';\n// hard deny when meta signature is required and invalid/missing\nif (metaSigRequired && !metaSigValid) {\n  denyReason = metaSigPresent ? 'WA_SIGNATURE_INVALID' : 'WA_SIGNATURE_MISSING';\n}\n// deny legacy token if presented but legacy is not allowed\nif (legacyOk && !legacyAllowed) {\n  denyReason = 'LEGACY_TOKEN_BLOCKED';\n}\n\n\n\nconst tenant_context = {\n  tenant_id: tenantId || null,\n  restaurant_id: restaurantId || null,\n  source: authMode === 'api_client' ? 'auth_db' : (authMode === 'legacy_shared' ? 'legacy_shared' : 'untrusted_payload'),\n  client_id: matched ? (e.client_id || null) : null,\n  client_name: matched ? (e.client_name || null) : null,\n  scopes\n};\n\n\nreturn [{\n  json: {\n    ...e,\n    tenantId,\n    restaurantId,\n    conversationKey,\n    tenant_context,\n      _auth: {\n      ...e._auth,\n      authOk,\n      authMode,\n      scopes,\n      requiredScopes,\n      scopeOk,\n      endpoint_group,\n      endpoint_path,\n      denyReason,\n      clientId: matched ? (e.client_id || null) : null,\n      clientName: matched ? (e.client_name || null) : null\n    }\n  }\n}];"
      },
      "id": "80046a7e-854b-4e57-b467-6f04fdc9f0ad",
      "name": "B0 - Apply Auth Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        480,
        -120
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO security_events(tenant_id, restaurant_id, conversation_key, channel, user_id, event_type, severity, payload_json) VALUES ($1,$2,$3,$4,$5,$6,'HIGH', jsonb_build_object('token_hash',$7,'ip',$8,'ua',$9,'tenant_hint',$10,'restaurant_hint',$11,'auth_mode',$12,'required_scopes',$13::jsonb,'scopes',$14::jsonb,'endpoint_group',$15,'endpoint_path',$16)) RETURNING 1;",
        "additionalFields": {
          "queryParams": "={{[null, null, null, $json.channel, $json.userId, ($json._auth.denyReason || 'AUTH_DENY'), $json._auth.tokenHash, $json.metadata.ip, $json.metadata.userAgent, $json._auth.tenantHint, $json._auth.restaurantHint, $json._auth.authMode, JSON.stringify($json._auth.requiredScopes || []), JSON.stringify($json._auth.scopes || []), $json._auth.endpoint_group, $json._auth.endpoint_path]}}"
        }
      },
      "id": "75fff6ee-5c2d-4e41-af59-f32d155f11e8",
      "name": "B0 - Log Deny (DB)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        520,
        80
      ]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json._contract.isValid}}",
              "operation": "isTrue"
            }
          ]
        }
      },
      "id": "b5de0a7b-d91b-4c56-a800-ba54988f2afb",
      "name": "B0 - Contract Valid?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -1900,
        0
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO security_events(tenant_id, restaurant_id, conversation_key, channel, user_id, event_type, severity, payload_json) VALUES (NULL,NULL,NULL,$1,$2,'CONTRACT_VALIDATION_FAILED','MEDIUM', jsonb_build_object('contract_version',$3,'schema_hash',$4,'errors',$5,'ip',$6,'ua',$7)) RETURNING 1;",
        "additionalFields": {
          "queryParams": "={{[$json.channel, $json.userId, $json._contract.version, $json._contract.schemaHash, $json._contract.errors, $json.metadata.ip, $json.metadata.userAgent]}}"
        }
      },
      "id": "f6aff14f-4f3b-4423-8e10-54c001184dbb",
      "name": "B0 - Log Contract Reject (DB)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2,
      "position": [
        -1630,
        180
      ]
    },
    {
      "parameters": {
        "responseCode": 400,
        "responseBody": "={{({error:'invalid_payload', contract_version:$json._contract.version, details:$json._contract.errors})}}",
        "options": {}
      },
      "id": "b5b00730-3173-45e9-aac3-681d29c8f7cf",
      "name": "RESP - 400 Invalid Payload",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        -1350,
        180
      ]
    },
    {
      "parameters": {
        "responseCode": 200,
        "responseBody": "={{$json}}",
        "options": {}
      },
      "id": "68ccf968-3999-4215-a047-39532cd9aed7",
      "name": "RESP - 200 OK",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        780,
        0
      ]
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "const crypto = require('crypto');\nconst e = $json;\nconst ctx = e.tenant_context || {};\nconst seal = crypto.createHash('sha256').update(JSON.stringify(ctx)).digest('hex');\nreturn [{json:{...e, tenant_context_seal: seal}}];\n"
      },
      "id": "5c64c6c3-b752-4ca8-8031-52d74044c660",
      "name": "B0 - Seal Tenant Context",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        730,
        -300
      ]
    },
    {
      "parameters": {
        "language": "JavaScript",
        "jsCode": "const crypto = require('crypto');\nconst e = $json;\nconst ctx = e.tenant_context || {};\nconst seal = crypto.createHash('sha256').update(JSON.stringify(ctx)).digest('hex');\nif (e.tenant_context_seal && seal !== e.tenant_context_seal) {\n  throw new Error('TENANT_CONTEXT_TAMPERED');\n}\nreturn [{json:e}];\n"
      },
      "id": "f87611bd-5bce-4a31-bf10-0c04b3e15d25",
      "name": "B0 - Verify Tenant Context Seal",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        50,
        -540
      ]
    }
  ],
  "connections": {
    "IN - Webhook": {
      "main": [
        [
          {
            "node": "B0 - Parse & Canonicalize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Parse & Canonicalize": {
      "main": [
        [
          {
            "node": "B0 - Contract Valid?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Token OK?": {
      "main": [
        [
          {
            "node": "B0 - Idempotency (DB)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B0 - Log Deny (DB)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Idempotency (DB)": {
      "main": [
        [
          {
            "node": "B0 - Idempotency Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Idempotency Flag": {
      "main": [
        [
          {
            "node": "B0 - Is New Msg?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Is New Msg?": {
      "main": [
        [
          {
            "node": "B0 - RateLimit + Log",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "END - Drop/Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - RateLimit + Log": {
      "main": [
        [
          {
            "node": "B0 - RateLimit Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - RateLimit Flag": {
      "main": [
        [
          {
            "node": "B0 - Rate OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Rate OK?": {
      "main": [
        [
          {
            "node": "B0 - Quarantine Check",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "END - Drop/Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Quarantine Check": {
      "main": [
        [
          {
            "node": "B0 - Quarantine Flag",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Quarantine Flag": {
      "main": [
        [
          {
            "node": "B0 - Not Quarantined?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Not Quarantined?": {
      "main": [
        [
          {
            "node": "B0 - Verify Tenant Context Seal",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "END - Drop/Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1 - Execute CORE_AGENT": {
      "main": [
        [
          {
            "node": "END - Drop/Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Resolve Client (DB)": {
      "main": [
        [
          {
            "node": "B0 - Apply Auth Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Apply Auth Context": {
      "main": [
        [
          {
            "node": "B0 - Seal Tenant Context",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Log Deny (DB)": {
      "main": [
        [
          {
            "node": "END - Drop/Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Contract Valid?": {
      "main": [
        [
          {
            "node": "B0 - Resolve Client (DB)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B0 - Log Contract Reject (DB)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Log Contract Reject (DB)": {
      "main": [
        [
          {
            "node": "RESP - 400 Invalid Payload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RESP - 400 Invalid Payload": {
      "main": [
        []
      ]
    },
    "END - Drop/Done": {
      "main": [
        [
          {
            "node": "RESP - 200 OK",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "RESP - 200 OK": {
      "main": [
        []
      ]
    },
    "B0 - Seal Tenant Context": {
      "main": [
        [
          {
            "node": "B0 - Token OK?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B0 - Verify Tenant Context Seal": {
      "main": [
        [
          {
            "node": "B1a - Admin WA Console?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1a - Admin WA Console?": {
      "main": [
        [
          {
            "node": "B1b - Execute ADMIN_WA_CONSOLE",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "B1 - Execute CORE_AGENT",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "B1b - Execute ADMIN_WA_CONSOLE": {
      "main": [
        [
          {
            "node": "END - Drop/Done",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  }
}