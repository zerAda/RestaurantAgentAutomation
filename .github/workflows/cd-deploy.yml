# =============================================================================
# CD Pipeline - Deploy to VPS (Diamond Level)
# =============================================================================
# Production-grade deployment with staging gate:
# CI passes (main) -> deploy-staging -> smoke-battery-staging -> [approval gate]
#   -> deploy-production -> smoke-battery-prod -> dora-metrics + notify + cleanup
# - Release directory model (/opt/resto/releases/<id>/)
# - Pre-deploy backup (pg_dump + config)
# - Migration gating (fail stops deploy)
# - Health checks + smoke tests (staging + production)
# - Automatic rollback on failure
# - Post-deploy cleanup
# - DORA metrics recording
# - Full observability (artifacts, summaries, notifications)
# =============================================================================
# Actions pinned to SHA for supply-chain security.
# VPS connection uses repository variables (not hardcoded).
# SSH user must be 'deploy' (not root) with docker group membership.
# Composite actions: setup-ssh, health-check, notify
# =============================================================================

name: CD - Deploy to VPS

on:
  workflow_run:
    workflows: ["CI Pipeline"]
    types: [completed]
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
      skip_backup:
        description: 'Skip database backup'
        required: false
        default: false
        type: boolean
      force_full_deploy:
        description: 'Force full deployment (treat as first deploy)'
        required: false
        default: false
        type: boolean

concurrency:
  group: deploy-${{ github.event.inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  # VPS configuration via repository variables (Settings > Variables > Actions)
  VPS_HOST: ${{ vars.VPS_HOST }}
  VPS_USER: ${{ vars.VPS_USER || 'deploy' }}
  PROJECT_DIR: ${{ vars.PROJECT_DIR || '/opt/resto' }}
  BACKUP_DIR: ${{ vars.BACKUP_DIR || '/opt/resto/backups' }}
  LOG_DIR: ${{ vars.LOG_DIR || '/var/log/resto-bot' }}
  HEALTH_URL: ${{ vars.HEALTH_URL }}
  DOMAIN: ${{ vars.DOMAIN }}
  KEEP_RELEASES: 5
  MAX_RETRIES: 15
  RETRY_INTERVAL: 10

permissions:
  contents: read
  deployments: write

jobs:
  # ============================================================================
  # JOB 1: Pre-flight checks
  # ============================================================================
  preflight:
    name: Pre-flight Checks
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 5

    outputs:
      version: ${{ steps.version.outputs.version }}
      deploy_id: ${{ steps.deploy_id.outputs.id }}
      release_dir: ${{ steps.deploy_id.outputs.release_dir }}
      environment: ${{ steps.env.outputs.environment }}
      is_first_deploy: ${{ steps.detect.outputs.is_first_deploy }}
      current_version: ${{ steps.detect.outputs.current_version }}

    steps:
      - name: Validate required variables
        run: |
          MISSING=0
          for var in VPS_HOST HEALTH_URL DOMAIN; do
            VAL=$(eval echo "\$$var")
            if [ -z "$VAL" ]; then
              echo "::error::Repository variable $var is not set (Settings > Variables > Actions)"
              MISSING=$((MISSING + 1))
            fi
          done
          if [ $MISSING -gt 0 ]; then
            exit 1
          fi

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Determine environment
        id: env
        run: echo "environment=${{ github.event.inputs.environment || 'production' }}" >> $GITHUB_OUTPUT

      - name: Get version
        id: version
        run: |
          VERSION=$(cat VERSION 2>/dev/null || echo "0.0.0")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Generate deployment ID
        id: deploy_id
        run: |
          DEPLOY_ID="$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}"
          echo "id=$DEPLOY_ID" >> $GITHUB_OUTPUT
          echo "release_dir=${{ env.PROJECT_DIR }}/releases/$DEPLOY_ID" >> $GITHUB_OUTPUT

      - name: Detect deployment type
        id: detect
        run: |
          RESULT=$(ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
            ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'ENDSSH'
            IS_FIRST="false"
            CURRENT_VER="none"

            # Check if current symlink exists
            if [ ! -L "/opt/resto/current" ] && [ ! -d "/opt/resto/current" ]; then
              IS_FIRST="true"
            fi

            # Get current version
            if [ -f "/opt/resto/current/VERSION" ]; then
              CURRENT_VER=$(cat /opt/resto/current/VERSION)
            fi

            echo "IS_FIRST=$IS_FIRST"
            echo "CURRENT_VER=$CURRENT_VER"
          ENDSSH
          )

          IS_FIRST=$(echo "$RESULT" | grep "IS_FIRST=" | cut -d= -f2)
          CURRENT_VER=$(echo "$RESULT" | grep "CURRENT_VER=" | cut -d= -f2)

          if [ "${{ github.event.inputs.force_full_deploy }}" = "true" ]; then
            IS_FIRST="true"
          fi

          echo "is_first_deploy=${IS_FIRST:-false}" >> $GITHUB_OUTPUT
          echo "current_version=${CURRENT_VER:-none}" >> $GITHUB_OUTPUT

      - name: Verify VPS disk space
        run: |
          DISK_FREE=$(ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \
            "df -BG / | tail -1 | awk '{print \$4}' | tr -d 'G'")
          if [ "$DISK_FREE" -lt 2 ]; then
            echo "::error::Insufficient disk space: ${DISK_FREE}GB free (minimum 2GB)"
            exit 1
          fi
          echo "Disk space: ${DISK_FREE}GB free"

      - name: Config drift detection
        run: |
          echo "=== Config drift detection ==="

          # Extract variable names from local config/.env.example
          LOCAL_VARS=$(grep -E '^[A-Z_][A-Z0-9_]*=' config/.env.example 2>/dev/null | cut -d= -f1 | sort)

          if [ -z "$LOCAL_VARS" ]; then
            echo "::notice::No config/.env.example found or empty - skipping drift check"
            exit 0
          fi

          # Extract variable names from VPS shared .env
          VPS_VARS=$(ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \
            "grep -E '^[A-Z_][A-Z0-9_]*=' ${{ env.PROJECT_DIR }}/shared/.env 2>/dev/null | cut -d= -f1 | sort" || echo "")

          if [ -z "$VPS_VARS" ]; then
            echo "::warning::No shared .env found on VPS at ${{ env.PROJECT_DIR }}/shared/.env - skipping drift check"
            exit 0
          fi

          # Find vars in .env.example that are missing from VPS .env
          MISSING_VARS=""
          for var in $LOCAL_VARS; do
            if ! echo "$VPS_VARS" | grep -qx "$var"; then
              MISSING_VARS="${MISSING_VARS}${var}\n"
            fi
          done

          if [ -n "$MISSING_VARS" ]; then
            echo "::warning::Config drift detected - variables in config/.env.example missing from VPS shared .env:"
            echo -e "$MISSING_VARS" | while read -r v; do
              [ -n "$v" ] && echo "::warning::  Missing var: $v"
            done
          else
            echo "No config drift detected - all .env.example vars present on VPS"
          fi

  # ============================================================================
  # JOB 2: Security Gate
  # ============================================================================
  security-gate:
    name: Security Gate
    runs-on: ubuntu-latest
    needs: preflight
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Scan for secrets (Gitleaks)
        run: |
          curl -sSL https://github.com/gitleaks/gitleaks/releases/download/v8.24.3/gitleaks_8.24.3_linux_x64.tar.gz | tar xz
          ./gitleaks detect --source . --config .gitleaks.toml --log-opts="--all" --verbose || {
            echo "::warning::Gitleaks found potential secrets - review required"
          }

      - name: Validate no .env committed
        run: |
          if git ls-files --error-unmatch .env 2>/dev/null; then
            echo "::error::.env is tracked by git"
            exit 1
          fi

  # ============================================================================
  # JOB 3: Deploy to Staging
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [preflight, security-gate]
    timeout-minutes: 20

    outputs:
      staging_status: ${{ steps.staging-smoke.outputs.status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Create staging directory
        run: |
          STAGING_DIR="${{ env.PROJECT_DIR }}/staging/${{ needs.preflight.outputs.deploy_id }}"
          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \
            "mkdir -p $STAGING_DIR"

      - name: Sync code to staging
        run: |
          STAGING_DIR="${{ env.PROJECT_DIR }}/staging/${{ needs.preflight.outputs.deploy_id }}"

          rsync -avz --delete \
            --exclude='.git' \
            --exclude='.env' \
            --exclude='secrets/' \
            --exclude='node_modules' \
            --exclude='__pycache__' \
            --exclude='.pytest_cache' \
            --exclude='*.pyc' \
            --exclude='.DS_Store' \
            -e "ssh -o StrictHostKeyChecking=no" \
            ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:$STAGING_DIR/

      - name: Prepare and start staging services
        run: |
          STAGING_DIR="${{ env.PROJECT_DIR }}/staging/${{ needs.preflight.outputs.deploy_id }}"
          PROJECT_DIR="${{ env.PROJECT_DIR }}"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e

            STAGING_DIR="$STAGING_DIR"

            # Link shared .env and secrets into staging release
            if [ -f "$PROJECT_DIR/shared/.env" ]; then
              ln -sf "$PROJECT_DIR/shared/.env" "\$STAGING_DIR/.env"
            fi

            if [ -d "$PROJECT_DIR/shared/secrets" ] && [ "\$(ls -A $PROJECT_DIR/shared/secrets 2>/dev/null)" ]; then
              ln -sf "$PROJECT_DIR/shared/secrets" "\$STAGING_DIR/secrets"
            fi

            # Use production compose file
            if [ -f "\$STAGING_DIR/docker-compose.hostinger.prod.yml" ]; then
              cp "\$STAGING_DIR/docker-compose.hostinger.prod.yml" "\$STAGING_DIR/docker-compose.yml"
            fi

            cd "\$STAGING_DIR"

            # Start staging with separate compose project name
            docker compose --project-name resto-staging pull --quiet 2>/dev/null || true
            docker compose --project-name resto-staging build --quiet 2>/dev/null || true
            docker compose --project-name resto-staging up -d --remove-orphans

            echo "Staging services started with project name: resto-staging"
            docker compose --project-name resto-staging ps
          ENDSSH

      - name: Run staging smoke tests
        id: staging-smoke
        run: |
          STAGING_DIR="${{ env.PROJECT_DIR }}/staging/${{ needs.preflight.outputs.deploy_id }}"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e
            cd $STAGING_DIR

            echo "=== Running scripts/smoke.sh against staging ==="
            if [ -f "scripts/smoke.sh" ]; then
              chmod +x scripts/smoke.sh
              bash scripts/smoke.sh || {
                echo "::error::Staging smoke tests failed"
                exit 1
              }
            else
              echo "::warning::scripts/smoke.sh not found - skipping staging smoke tests"
            fi
          ENDSSH

          echo "status=passed" >> $GITHUB_OUTPUT

      - name: Stop staging services
        if: always()
        run: |
          STAGING_DIR="${{ env.PROJECT_DIR }}/staging/${{ needs.preflight.outputs.deploy_id }}"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            if [ -d "$STAGING_DIR" ]; then
              cd "$STAGING_DIR"
              docker compose --project-name resto-staging down --remove-orphans 2>/dev/null || true
              echo "Staging services stopped"
            fi
          ENDSSH

  # ============================================================================
  # JOB 4: Staging Smoke Battery
  # ============================================================================
  smoke-battery-staging:
    name: Smoke Battery (Staging)
    runs-on: ubuntu-latest
    needs: [preflight, deploy-staging]
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Validate staging deployment result
        run: |
          if [ "${{ needs.deploy-staging.outputs.staging_status }}" != "passed" ]; then
            echo "::error::Staging smoke tests did not pass"
            exit 1
          fi
          echo "Staging validation confirmed: smoke tests passed"

  # ============================================================================
  # JOB 5: Production Approval Gate
  # ============================================================================
  approve-production:
    name: Approve Production Deploy
    runs-on: ubuntu-latest
    needs: [preflight, smoke-battery-staging]
    environment:
      name: production
    timeout-minutes: 60

    steps:
      - name: Approval confirmed
        run: |
          echo "Production deployment approved"
          echo "Version: ${{ needs.preflight.outputs.version }}"
          echo "Deploy ID: ${{ needs.preflight.outputs.deploy_id }}"
          echo "Commit: ${{ github.sha }}"

  # ============================================================================
  # JOB 6: Pre-deployment backup
  # ============================================================================
  backup:
    name: Pre-deploy Backup
    runs-on: ubuntu-latest
    needs: [preflight, approve-production]
    if: |
      needs.preflight.outputs.is_first_deploy != 'true' &&
      github.event.inputs.skip_backup != 'true'
    timeout-minutes: 15

    outputs:
      backup_name: ${{ steps.backup.outputs.name }}

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Create backup (n8n + strapi DBs)
        id: backup
        run: |
          BACKUP_NAME="deploy-${{ needs.preflight.outputs.deploy_id }}"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e
            BACKUP_DIR="${{ env.BACKUP_DIR }}"
            mkdir -p "\$BACKUP_DIR"
            cd ${{ env.PROJECT_DIR }}/current 2>/dev/null || cd ${{ env.PROJECT_DIR }}

            echo "=== Backup: n8n database ==="
            docker compose exec -T postgres pg_dump -U n8n -d n8n \
              --no-owner --no-acl -Fc \
              > "\$BACKUP_DIR/${BACKUP_NAME}-n8n.dump"

            echo "=== Backup: strapi database ==="
            docker compose exec -T postgres pg_dump -U n8n -d strapi \
              --no-owner --no-acl -Fc \
              > "\$BACKUP_DIR/${BACKUP_NAME}-strapi.dump" 2>/dev/null || echo "Strapi DB not found (OK for first setup)"

            echo "=== Backup: config ==="
            tar -czf "\$BACKUP_DIR/${BACKUP_NAME}-config.tar.gz" \
              -C "${{ env.PROJECT_DIR }}/current" \
              .env secrets/ 2>/dev/null || true

            # Verify n8n backup integrity
            if [ ! -s "\$BACKUP_DIR/${BACKUP_NAME}-n8n.dump" ]; then
              echo "::error::n8n backup is empty"
              exit 1
            fi

            # Metadata
            cat > "\$BACKUP_DIR/${BACKUP_NAME}-meta.json" << METAEOF
          {
            "timestamp": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "version": "${{ needs.preflight.outputs.version }}",
            "commit": "${{ github.sha }}",
            "type": "pre-deploy"
          }
          METAEOF

            ls -lh "\$BACKUP_DIR/${BACKUP_NAME}"*
            echo "Backup complete: ${BACKUP_NAME}"
          ENDSSH

          echo "name=$BACKUP_NAME" >> $GITHUB_OUTPUT

  # ============================================================================
  # JOB 7: Deploy to Production
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [preflight, approve-production, backup]
    if: |
      always() &&
      needs.preflight.result == 'success' &&
      needs.approve-production.result == 'success' &&
      (needs.backup.result == 'success' || needs.backup.result == 'skipped')
    timeout-minutes: 20

    outputs:
      status: ${{ steps.health.outputs.status }}
      deploy_start: ${{ steps.timer.outputs.start }}

    steps:
      - name: Record deploy start time
        id: timer
        run: echo "start=$(date +%s)" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Create release directory
        run: |
          RELEASE_DIR="${{ needs.preflight.outputs.release_dir }}"
          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} \
            "mkdir -p $RELEASE_DIR"

      - name: Sync code to release directory
        run: |
          RELEASE_DIR="${{ needs.preflight.outputs.release_dir }}"

          rsync -avz --delete \
            --exclude='.git' \
            --exclude='.env' \
            --exclude='secrets/' \
            --exclude='node_modules' \
            --exclude='__pycache__' \
            --exclude='.pytest_cache' \
            --exclude='*.pyc' \
            --exclude='.DS_Store' \
            -e "ssh -o StrictHostKeyChecking=no" \
            ./ ${{ env.VPS_USER }}@${{ env.VPS_HOST }}:$RELEASE_DIR/

      - name: Link shared resources and activate release
        run: |
          RELEASE_DIR="${{ needs.preflight.outputs.release_dir }}"
          PROJECT_DIR="${{ env.PROJECT_DIR }}"
          IS_FIRST="${{ needs.preflight.outputs.is_first_deploy }}"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e

            # Create shared directories (persist across releases)
            mkdir -p "$PROJECT_DIR/shared/secrets"
            mkdir -p "$PROJECT_DIR/shared"
            mkdir -p "$PROJECT_DIR/releases"
            mkdir -p "${{ env.BACKUP_DIR }}"
            mkdir -p "${{ env.LOG_DIR }}"

            RELEASE_DIR="$RELEASE_DIR"

            # Link shared .env and secrets into release
            if [ -f "$PROJECT_DIR/shared/.env" ]; then
              ln -sf "$PROJECT_DIR/shared/.env" "\$RELEASE_DIR/.env"
            elif [ -f "$PROJECT_DIR/current/.env" ] && [ "\$IS_FIRST" != "true" ]; then
              cp "$PROJECT_DIR/current/.env" "$PROJECT_DIR/shared/.env"
              ln -sf "$PROJECT_DIR/shared/.env" "\$RELEASE_DIR/.env"
            fi

            if [ -d "$PROJECT_DIR/shared/secrets" ] && [ "\$(ls -A $PROJECT_DIR/shared/secrets 2>/dev/null)" ]; then
              ln -sf "$PROJECT_DIR/shared/secrets" "\$RELEASE_DIR/secrets"
            elif [ -d "$PROJECT_DIR/current/secrets" ] && [ "\$IS_FIRST" != "true" ]; then
              cp -rp "$PROJECT_DIR/current/secrets/"* "$PROJECT_DIR/shared/secrets/" 2>/dev/null || true
              ln -sf "$PROJECT_DIR/shared/secrets" "\$RELEASE_DIR/secrets"
            fi

            # Use production compose file as docker-compose.yml
            if [ -f "\$RELEASE_DIR/docker-compose.hostinger.prod.yml" ]; then
              cp "\$RELEASE_DIR/docker-compose.hostinger.prod.yml" "\$RELEASE_DIR/docker-compose.yml"
            fi

            # Create volumes if needed (first deploy)
            if [ "\$IS_FIRST" = "true" ]; then
              for vol in traefik_data n8n_data postgres_data redis_data cms_uploads ollama_data; do
                docker volume create \$vol 2>/dev/null || true
              done
            fi

            echo "Release prepared: \$RELEASE_DIR"
          ENDSSH

      - name: Pull images
        run: |
          RELEASE_DIR="${{ needs.preflight.outputs.release_dir }}"
          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e
            cd $RELEASE_DIR
            docker compose pull --quiet 2>/dev/null || true
            docker compose build --quiet 2>/dev/null || true
          ENDSSH

      - name: Run migrations (gated)
        id: migrate
        run: |
          RELEASE_DIR="${{ needs.preflight.outputs.release_dir }}"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e
            cd $RELEASE_DIR

            echo "=== Starting DB services ==="
            docker compose up -d postgres redis
            echo "Waiting for postgres..."
            for i in \$(seq 1 30); do
              if docker compose exec -T postgres pg_isready -U n8n -d n8n >/dev/null 2>&1; then
                echo "PostgreSQL ready"
                break
              fi
              sleep 2
            done

            echo "=== Running db-migrate service ==="
            docker compose up db-migrate
            MIGRATE_EXIT=\$(docker compose ps db-migrate --format '{{.ExitCode}}' 2>/dev/null || echo "0")

            if [ "\$MIGRATE_EXIT" != "0" ] && [ "\$MIGRATE_EXIT" != "" ]; then
              echo "::error::Migration failed (exit code: \$MIGRATE_EXIT)"
              docker compose logs db-migrate --tail=50
              exit 1
            fi

            echo "Migrations complete"
          ENDSSH

      - name: Activate release (symlink cutover)
        run: |
          RELEASE_DIR="${{ needs.preflight.outputs.release_dir }}"
          PROJECT_DIR="${{ env.PROJECT_DIR }}"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e
            cd $RELEASE_DIR

            echo "=== Starting all services ==="
            docker compose up -d --remove-orphans

            echo "=== Activating release symlink ==="
            ln -sfn "$RELEASE_DIR" "$PROJECT_DIR/current"

            echo "Active release: \$(readlink $PROJECT_DIR/current)"
            docker compose ps
          ENDSSH

      - name: Health check
        id: health
        uses: ./.github/actions/health-check
        with:
          url: ${{ env.HEALTH_URL }}
          max-retries: ${{ env.MAX_RETRIES }}
          retry-interval: ${{ env.RETRY_INTERVAL }}
          expected-code: '200'

      - name: Collect failure artifacts
        if: failure()
        run: |
          echo "=== Failure Diagnostics ===" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'ENDSSH' >> $GITHUB_STEP_SUMMARY 2>&1
            echo "--- docker compose ps ---"
            cd /opt/resto/current 2>/dev/null && docker compose ps 2>/dev/null || echo "compose not available"
            echo ""
            echo "--- docker compose logs (last 30 lines) ---"
            cd /opt/resto/current 2>/dev/null && docker compose logs --tail=30 2>/dev/null || echo "logs not available"
            echo ""
            echo "--- disk usage ---"
            df -h / | tail -1
            echo ""
            echo "--- memory ---"
            free -m | head -2
            echo ""
            echo "--- listening ports ---"
            ss -tulpn 2>/dev/null | head -20 || netstat -tulpn 2>/dev/null | head -20
          ENDSSH

          echo '```' >> $GITHUB_STEP_SUMMARY

      - name: Record deployment
        if: success()
        run: |
          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            mkdir -p ${{ env.LOG_DIR }}
            echo "${{ needs.preflight.outputs.version }}" > ${{ env.LOG_DIR }}/current_version

            cat >> ${{ env.LOG_DIR }}/deployments.log << EOF

          ================================================================================
          Deployment: ${{ needs.preflight.outputs.deploy_id }}
          Version:    ${{ needs.preflight.outputs.version }}
          Previous:   ${{ needs.preflight.outputs.current_version }}
          Commit:     ${{ github.sha }}
          Branch:     ${{ github.ref_name }}
          Actor:      ${{ github.actor }}
          Release:    ${{ needs.preflight.outputs.release_dir }}
          Timestamp:  \$(date -u +%Y-%m-%dT%H:%M:%SZ)
          Status:     SUCCESS
          ================================================================================
          EOF
          ENDSSH

  # ============================================================================
  # JOB 8: Production Smoke Battery
  # ============================================================================
  smoke-battery-prod:
    name: Smoke Battery (Production)
    runs-on: ubuntu-latest
    needs: [preflight, deploy-production]
    timeout-minutes: 10

    outputs:
      status: ${{ steps.smoke.outputs.status }}

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Execute smoke.sh on VPS
        id: smoke-script
        run: |
          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e
            cd ${{ env.PROJECT_DIR }}/current

            echo "=== Running scripts/smoke.sh against production ==="
            if [ -f "scripts/smoke.sh" ]; then
              chmod +x scripts/smoke.sh
              bash scripts/smoke.sh || {
                echo "::error::Production smoke.sh failed"
                exit 1
              }
            else
              echo "::warning::scripts/smoke.sh not found on VPS"
            fi
          ENDSSH

      - name: Test WA/IG/MSG endpoints
        id: smoke
        run: |
          TESTS_PASSED=0
          TESTS_TOTAL=3

          # 1: WhatsApp inbound endpoint
          WA_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://api.${{ env.DOMAIN }}/v1/inbound/whatsapp?hub.mode=subscribe&hub.verify_token=test&hub.challenge=test" || echo "000")
          if [ "$WA_CODE" != "000" ] && [ "$WA_CODE" != "502" ] && [ "$WA_CODE" != "503" ]; then
            echo "1. WhatsApp endpoint: PASS (HTTP $WA_CODE)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "1. WhatsApp endpoint: FAIL (HTTP $WA_CODE)"
          fi

          # 2: Instagram inbound endpoint
          IG_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://api.${{ env.DOMAIN }}/v1/inbound/instagram?hub.mode=subscribe&hub.verify_token=test&hub.challenge=test" || echo "000")
          if [ "$IG_CODE" != "000" ] && [ "$IG_CODE" != "502" ] && [ "$IG_CODE" != "503" ]; then
            echo "2. Instagram endpoint: PASS (HTTP $IG_CODE)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "2. Instagram endpoint: FAIL (HTTP $IG_CODE)"
          fi

          # 3: Messenger inbound endpoint
          MSG_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://api.${{ env.DOMAIN }}/v1/inbound/messenger?hub.mode=subscribe&hub.verify_token=test&hub.challenge=test" || echo "000")
          if [ "$MSG_CODE" != "000" ] && [ "$MSG_CODE" != "502" ] && [ "$MSG_CODE" != "503" ]; then
            echo "3. Messenger endpoint: PASS (HTTP $MSG_CODE)"
            TESTS_PASSED=$((TESTS_PASSED + 1))
          else
            echo "3. Messenger endpoint: FAIL (HTTP $MSG_CODE)"
          fi

          echo ""
          echo "Channel smoke tests: $TESTS_PASSED/$TESTS_TOTAL passed"

          if [ $TESTS_PASSED -lt 2 ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "::error::Channel smoke tests failed ($TESTS_PASSED/$TESTS_TOTAL)"
            exit 1
          fi
          echo "status=passed" >> $GITHUB_OUTPUT

  # ============================================================================
  # JOB 9: DORA Metrics
  # ============================================================================
  dora-metrics:
    name: DORA Metrics
    runs-on: ubuntu-latest
    needs: [preflight, deploy-production, smoke-battery-prod]
    if: always() && needs.deploy-production.result != 'cancelled'
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Record DORA metrics
        run: |
          DEPLOY_START="${{ needs.deploy-production.outputs.deploy_start }}"
          DEPLOY_END=$(date +%s)
          DEPLOY_DURATION=$((DEPLOY_END - DEPLOY_START))

          # Calculate lead time (time from commit to deploy)
          COMMIT_TS=$(git log -1 --format=%ct "${{ github.sha }}" 2>/dev/null || echo "$DEPLOY_START")
          LEAD_TIME=$((DEPLOY_END - COMMIT_TS))

          # Determine status
          if [ "${{ needs.smoke-battery-prod.result }}" = "success" ] && [ "${{ needs.deploy-production.result }}" = "success" ]; then
            STATUS="success"
          else
            STATUS="failure"
          fi

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << ENDSSH
            set -e
            mkdir -p ${{ env.LOG_DIR }}

            # Check if scripts/dora_metrics.sh exists on VPS
            if [ -f "${{ env.PROJECT_DIR }}/current/scripts/dora_metrics.sh" ]; then
              cd ${{ env.PROJECT_DIR }}/current
              chmod +x scripts/dora_metrics.sh
              bash scripts/dora_metrics.sh \
                --version "${{ needs.preflight.outputs.version }}" \
                --commit "${{ github.sha }}" \
                --status "$STATUS" \
                --lead-time "$LEAD_TIME" \
                --deploy-duration "$DEPLOY_DURATION"
            else
              # Inline DORA metrics recording
              TIMESTAMP="\$(date -u +%Y-%m-%dT%H:%M:%SZ)"
              echo '{"timestamp":"'\$TIMESTAMP'","version":"${{ needs.preflight.outputs.version }}","commit":"${{ github.sha }}","status":"$STATUS","lead_time_sec":'$LEAD_TIME',"deploy_duration_sec":'$DEPLOY_DURATION'}' \
                >> ${{ env.LOG_DIR }}/dora_metrics.jsonl
              echo "DORA metrics recorded (inline) to ${{ env.LOG_DIR }}/dora_metrics.jsonl"
            fi
          ENDSSH

          echo "DORA Metrics:"
          echo "  Status: $STATUS"
          echo "  Version: ${{ needs.preflight.outputs.version }}"
          echo "  Lead Time: ${LEAD_TIME}s"
          echo "  Deploy Duration: ${DEPLOY_DURATION}s"

  # ============================================================================
  # JOB 10: Cleanup
  # ============================================================================
  cleanup:
    name: Post-deploy Cleanup
    runs-on: ubuntu-latest
    needs: [preflight, deploy-production, smoke-battery-prod]
    if: needs.deploy-production.result == 'success'
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Cleanup old releases and Docker artifacts
        run: |
          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'ENDSSH'
            set -e
            echo "=== Disk BEFORE cleanup ==="
            df -h / | tail -1

            # 1. Prune old releases (keep KEEP_RELEASES=5)
            RELEASES_DIR="/opt/resto/releases"
            if [ -d "$RELEASES_DIR" ]; then
              CURRENT=$(readlink /opt/resto/current 2>/dev/null || echo "")
              RELEASE_COUNT=$(ls -1d $RELEASES_DIR/*/ 2>/dev/null | wc -l)
              echo "Releases: $RELEASE_COUNT (keeping 5)"

              if [ "$RELEASE_COUNT" -gt 5 ]; then
                ls -1dt $RELEASES_DIR/*/ | tail -n +6 | while read old_release; do
                  if [ "$old_release" != "$CURRENT" ] && [ "$old_release" != "$CURRENT/" ]; then
                    echo "Removing old release: $old_release"
                    rm -rf "$old_release"
                  fi
                done
              fi
            fi

            # 2. Cleanup staging directory
            STAGING_DIR="/opt/resto/staging"
            if [ -d "$STAGING_DIR" ]; then
              echo "Cleaning up staging directory"
              rm -rf "$STAGING_DIR"/*
            fi

            # 3. Docker cleanup (safe)
            docker image prune -f 2>/dev/null || true
            docker builder prune -f --keep-storage 1GB 2>/dev/null || true

            # 4. Old backup cleanup (keep 10 deploy backups, 7 daily, 4 weekly)
            BACKUP_DIR="/opt/resto/backups"
            if [ -d "$BACKUP_DIR" ]; then
              ls -t $BACKUP_DIR/deploy-*-n8n.dump 2>/dev/null | tail -n +11 | xargs -r rm -v
              ls -t $BACKUP_DIR/deploy-*-strapi.dump 2>/dev/null | tail -n +11 | xargs -r rm -v
              ls -t $BACKUP_DIR/deploy-*-config.tar.gz 2>/dev/null | tail -n +11 | xargs -r rm -v
              ls -t $BACKUP_DIR/deploy-*-meta.json 2>/dev/null | tail -n +11 | xargs -r rm -v
              ls -t $BACKUP_DIR/daily-*-db.dump.gz 2>/dev/null | tail -n +8 | xargs -r rm -v
              ls -t $BACKUP_DIR/full-*-db.dump.gz 2>/dev/null | tail -n +5 | xargs -r rm -v
              find $BACKUP_DIR -name "pre-rollback-*" -mtime +3 -delete 2>/dev/null || true
            fi

            # 5. Journal cleanup
            journalctl --vacuum-time=7d 2>/dev/null || true

            echo "=== Disk AFTER cleanup ==="
            df -h / | tail -1

            echo "=== Docker disk usage ==="
            docker system df
          ENDSSH

  # ============================================================================
  # JOB 11: Post-deployment (rollback + summary + notification)
  # ============================================================================
  post-deploy:
    name: Post-deployment
    runs-on: ubuntu-latest
    needs: [preflight, security-gate, deploy-staging, smoke-battery-staging, approve-production, backup, deploy-production, smoke-battery-prod, dora-metrics, cleanup]
    if: always()
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup SSH
        if: needs.deploy-production.result == 'failure' || needs.smoke-battery-prod.result == 'failure'
        uses: ./.github/actions/setup-ssh
        with:
          ssh-key: ${{ secrets.VPS_SSH_KEY }}
          vps-host: ${{ env.VPS_HOST }}

      - name: Auto-rollback on failure
        if: needs.deploy-production.result == 'failure' || needs.smoke-battery-prod.result == 'failure'
        run: |
          echo "::warning::Deployment failed — initiating rollback"

          ssh -o StrictHostKeyChecking=no ${{ env.VPS_USER }}@${{ env.VPS_HOST }} << 'ENDSSH'
            set -e
            PROJECT_DIR="/opt/resto"

            # Find previous release (second newest)
            CURRENT=$(readlink "$PROJECT_DIR/current" 2>/dev/null || echo "")
            PREVIOUS=$(ls -1dt $PROJECT_DIR/releases/*/ 2>/dev/null | grep -v "$(basename $CURRENT)" | head -1)

            if [ -z "$PREVIOUS" ]; then
              echo "::error::No previous release found for rollback"
              exit 1
            fi

            echo "Rolling back to: $PREVIOUS"

            # Switch symlink to previous release
            ln -sfn "$PREVIOUS" "$PROJECT_DIR/current"
            cd "$PROJECT_DIR/current"

            # Restart with previous release
            docker compose up -d --remove-orphans

            sleep 30

            # Verify
            if docker compose exec -T postgres pg_isready -U n8n >/dev/null 2>&1; then
              echo "Rollback successful — services running"
            else
              echo "::error::Rollback may have failed — manual intervention required"
            fi
          ENDSSH

      - name: Deployment summary
        run: |
          DEPLOY_STATUS="FAILED"
          if [ "${{ needs.deploy-production.result }}" = "success" ] && [ "${{ needs.smoke-battery-prod.result }}" = "success" ]; then
            DEPLOY_STATUS="SUCCESS"
          fi

          cat >> $GITHUB_STEP_SUMMARY << EOF
          ## Deployment Summary

          | Property | Value |
          |----------|-------|
          | **Status** | ${DEPLOY_STATUS} |
          | **Version** | ${{ needs.preflight.outputs.version }} |
          | **Previous** | ${{ needs.preflight.outputs.current_version }} |
          | **Deploy ID** | ${{ needs.preflight.outputs.deploy_id }} |
          | **Release Dir** | ${{ needs.preflight.outputs.release_dir }} |
          | **Environment** | ${{ needs.preflight.outputs.environment }} |
          | **Commit** | \`${{ github.sha }}\` |
          | **Branch** | \`${{ github.ref_name }}\` |
          | **Backup** | ${{ needs.backup.outputs.backup_name || 'skipped' }} |

          ### Job Results
          | Job | Result |
          |-----|--------|
          | Preflight | ${{ needs.preflight.result }} |
          | Security Gate | ${{ needs.security-gate.result }} |
          | Deploy Staging | ${{ needs.deploy-staging.result }} |
          | Smoke Battery Staging | ${{ needs.smoke-battery-staging.result }} |
          | Approve Production | ${{ needs.approve-production.result }} |
          | Backup | ${{ needs.backup.result || 'skipped' }} |
          | Deploy Production | ${{ needs.deploy-production.result }} |
          | Smoke Battery Prod | ${{ needs.smoke-battery-prod.result }} |
          | DORA Metrics | ${{ needs.dora-metrics.result }} |
          | Cleanup | ${{ needs.cleanup.result || 'skipped' }} |
          EOF

      - name: Notify on failure
        if: needs.deploy-production.result == 'failure' || needs.smoke-battery-prod.result == 'failure'
        uses: ./.github/actions/notify
        with:
          webhook-url: ${{ secrets.ALERT_WEBHOOK_URL }}
          status: failure
          title: "Deployment FAILED - v${{ needs.preflight.outputs.version }}"
          version: ${{ needs.preflight.outputs.version }}
          environment: ${{ needs.preflight.outputs.environment }}
          details: "Auto-rollback initiated. Actor: ${{ github.actor }}"
          commit-sha: ${{ github.sha }}

      - name: Notify on success
        if: needs.deploy-production.result == 'success' && needs.smoke-battery-prod.result == 'success'
        uses: ./.github/actions/notify
        with:
          webhook-url: ${{ secrets.ALERT_WEBHOOK_URL }}
          status: success
          title: "Deployment SUCCESS - v${{ needs.preflight.outputs.version }}"
          version: ${{ needs.preflight.outputs.version }}
          environment: ${{ needs.preflight.outputs.environment }}
          details: "Deploy ID: ${{ needs.preflight.outputs.deploy_id }}. All smoke tests passed."
          commit-sha: ${{ github.sha }}
